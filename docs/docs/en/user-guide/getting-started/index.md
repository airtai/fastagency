---
# 0.5 - API
# 2 - Release
# 3 - Contributing
# 5 - Template Page
# 10 - Default
# hide:
#   - navigation

search:
  boost: 10
---

# Quick start

You can try out FastAgency to build and deploy your multi-agent application in less than one hour by following this guide. You will learn how to write you workflow, test and debug it and finally deploy it on cloud. The deployed application will have chat interface.

You can use three different setups, depending on how scalable solution you need:

- **Mesop**: This setup uses [**Mesop**](https://google.github.io/mesop/){target="_blank"}
    to build a web application for interacting with our workflow. It supports
    a single-worker deployments only, limiting its scalability. However, it
    is the fastest way to build and test your application.

- **FastAPI + Mesop**: This is fairly scalable setup using [**FastAPI**](https://fastapi.tiangolo.com/){target="_blank"} to execute your workflows and [**Mesop**](https://google.github.io/mesop/){target="_blank"} for interactive web application. [**FastAPI**](https://fastapi.tiangolo.com/){target="_blank"} supports execution with multiple workers, with each workflow being executed in the context of a WebSocket connection. [**Mesop**](https://google.github.io/mesop/){target="_blank"} is still limited to a single worker, although there is much less load on it due to workflows being executed in the [**FastAPI**](https://fastapi.tiangolo.com/){target="_blank"} workers.

- **NATS + FastAPI + Mesop**: This is the most scalable setup using a distributed message broker
    [**NATS.io MQ**](https://nats.io/){target="_blank"}. Workflows are being executed with
    multiple workers that attach to the MQ waiting for initiate workflow messages. Such workers
    can be running on different machines or even different data centers/cloud providers.
    Message queues are highly scalable, but more difficult to integrate with end-clients.
    In order to make such integrations easier, we will connect our [**NATS**](https://nats.io/){target="_blank"}-based message queue with the [**FastAPI**](https://fastapi.tiangolo.com/){target="_blank"} application.


## Project setup

We **strongly recommend** using [**Cookiecutter**](../cookiecutter/index.md) for setting up a FastAgency project. It creates the project folder structure, default workflow, automatically installs all the necessary requirements, and creates a [devcontainer](https://code.visualstudio.com/docs/devcontainers/containers){target="_blank"} that can be used with [Visual Studio Code](https://code.visualstudio.com/){target="_blank"} for development.

You could also use virtual environment managers such as [venv](https://docs.python.org/3/library/venv.html){target="_blank"}, and a Python package manager, such as [pip](https://en.wikipedia.org/wiki/Pip_(package_manager)).


{! docs/en/user-guide/cookiecutter/index.md[ln:6-226] !}

!!! info
    If you used a different `project_slug` than the default `my_fastagency_app` this will be reflected in the project module naming. Keep this in mind when running the commands further in this guide (in [Run Application](#run-application-locally)), you will need to replace `my_fastagency_app` with your `project_slug` name.
-----

## Workflow Development

### Define the Workflow

You need to define the workflow that your application will use. This is where you specify how the agents interact and what they do. Here's a simple example of a workflow definition as it is generated by the cookie cutter under `my_fastagency_app/workflow.py`:

```python
{! docs_src/getting_started/basic_auth/mesop/my_fastagency_app/my_fastagency_app/workflow.py !}
```

This code snippet sets up a simple learning chat between a student and a teacher. It defines the agents and how they should interact and specify how the conversation should be summarized.

### Run and Debug the Workflow

To ensure that the workflow we have defined is working properly, we can test it locally using MesopUI. The code below can be found under `my_fastagency_app/local/main_mesop.py` and imports the defined workflow and sets up MesopUI:

```python
{! docs_src/getting_started/basic_auth/mesop/my_fastagency_app/my_fastagency_app/local/main_mesop.py !}
```

Run MesopUI locally with the following command:

=== "Linux/MacOS"
    !!! note "Terminal"
        ```console
        gunicorn my_fastagency_app.local.main_mesop:app
        ```

=== "Windows"
    !!! note "Terminal"
        ```console
        waitress-serve --listen=0.0.0.0:8000 my_fastagency_app.local.main_mesop:app
        ```

Open the MesopUI URL [http://localhost:8000](http://localhost:8000) in your browser. You can now use the graphical user interface to start, run, test and debug the autogen workflow manually.

![Initial message](./images/chat-init.png)

### Run Workflow Tests

We can also use pytest to test the autogen workflow automatically, instead of manually testing it using MesopUI by using the generated `pytest` test found under `tests/test_workflow.py`.

```python
{! docs_src/getting_started/basic_auth/mesop/my_fastagency_app/tests/test_workflow.py !}
```

Run the test with the following command:

```console
pytest -s
```

Running the test could take up to 30 seconds, depending on latency and throughput of OpenAI (or other LLM providers).

## Deployment files

Depending on the interface you choose when setting up the project with`cookiecutter`, appropriate deployment files will be generated under `my_fastagency_app/deployment` folder. We'll quickly explain what they contain and how to use them.

### Registering workflow with a UI or a provider

The workflow definition will be registered either directly with an UI object or a network provider that will propagate messages back and forth over a network protocol.

=== "Mesop"
    In the case of a simple Mesop application, will register the workflow directly with `MesopUI` object and run it in the same process.

    ```python

    {!> docs_src/getting_started/basic_auth/mesop/my_fastagency_app/my_fastagency_app/deployment/main.py !}

    ```

=== "FastAPI + Mesop"
    In the case of FastAPI application, we will create an `FastAPIAdapter` and then include a router to the `FastAPI` application.
    The adapter will have all REST and Websocket routes for communicating with a client.

    ```python
    {!> docs_src/getting_started/basic_auth/fastapi/my_fastagency_app/my_fastagency_app/deployment/main_1_fastapi.py !}
    ```

=== "NATS + FastAPI + Mesop"
    In the case of NATS.io application, we will create an `NatsAdapter` and then
    add it to a `FastAPI` application using the `lifespan` parameter. The adapter
    will have all REST and Websocket routes for communicating with a client.

    ```python
    {!> docs_src/getting_started/basic_auth/nats_n_fastapi/my_fastagency_app/my_fastagency_app/deployment/main_1_nats.py !}

    ```
    The `NatsAdapter` requires a running NATS server. The easiest way to start the NATS server is by using [Docker](https://www.docker.com/){target="_blank"}. FastAgency uses the [JetStream](https://docs.nats.io/nats-concepts/jetstream){target="_blank"} feature of NATS and also utilizes authentication.

    ```
    {!> docs_src/getting_started/basic_auth/nats_n_fastapi/my_fastagency_app/.devcontainer/nats_server.conf !}
    ```

    In the above NATS configuration, we define a user called `fastagency`, and its password is read from the environment variable `FASTAGENCY_NATS_PASSWORD`. We also enable JetStream in NATS and configure NATS to serve via the appropriate ports.

### Adapter Chaining

In case we used network adapters in the step above, we can chain additional network adapters or UI objects to it.

=== "Mesop"
    Not applicable for this setup as there are no adapters used.

=== "FastAPI + Mesop"

    There is an additional specification file for an application using `MesopUI`
    to connect to the `FastAPIAdapter`

    !!! note "main_2_mesop.py"
        ```python
        {!> docs_src/getting_started/basic_auth/fastapi/my_fastagency_app/my_fastagency_app/deployment/main_2_mesop.py !}
        ```

=== "NATS + FastAPI + Mesop"

    Above, we created NATS.io provider that will start brokers waiting to consume
    initiate workflow messages from the message broker. Now, we create FastAPI
    service interacting with NATS.io provider:

    !!! note "main_2_fastapi.py"
        ```python
        {!> docs_src/getting_started/basic_auth/nats_n_fastapi/my_fastagency_app/my_fastagency_app/deployment/main_2_fastapi.py !}
        ```

    Finally, we create Mesop app communicating with the FastAPI application:

    !!! note "main_3_mesop.py"
        ```python
        {!> docs_src/getting_started/basic_auth/nats_n_fastapi/my_fastagency_app/my_fastagency_app/deployment/main_3_mesop.py !}
        ```

### Authentication

FastAgency provides three types of authentication mechanisms: [**Basic Authentication**](../../api/fastagency/ui/mesop/auth/basic_auth/BasicAuth.md), [**Firebase Authentication**](../../api/fastagency/ui/mesop/auth/firebase/FirebaseAuth.md) and no authentication (more will be added soon). The default authentication mechanism is [**Basic Authentication**](../../api/fastagency/ui/mesop/auth/basic_auth/BasicAuth.md). You can choose the type of authentication while setting up the project with Cookiecutter.

To use Basic Authentication, configure the desired usernames and their bcrypt hashed passwords in the BasicAuth class and apply the authentication object to the MesopUI object.

=== "Mesop"

    !!! note "main.py"
        ```python
        {!> docs_src/getting_started/basic_auth/mesop/my_fastagency_app/my_fastagency_app/deployment/main.py !}
        ```

=== "FastAPI + Mesop"

    !!! note "main_2_mesop.py"
        ```python
        {!> docs_src/getting_started/basic_auth/fastapi/my_fastagency_app/my_fastagency_app/deployment/main_2_mesop.py !}
        ```

=== "NATS + FastAPI + Mesop"

    !!! note "main_3_mesop.py"
        ```python
        {!> docs_src/getting_started/basic_auth/nats_n_fastapi/my_fastagency_app/my_fastagency_app/deployment/main_3_mesop.py !}
        ```

## Run Application Locally

Once everything is set up, you can run your FastAgency application using the following command:

=== "Mesop"

    The preferred way to run the [**Mesop**](https://google.github.io/mesop/){target="_blank"} application is using a Python WSGI HTTP server like [**Gunicorn**](https://gunicorn.org/){target="_blank"} on Linux and Mac or [**Waitress**](https://docs.pylonsproject.org/projects/waitress/en/stable/){target="_blank"} on Windows.

    - In the root of your project run:
    !!! note "Terminal"
        ```console
        gunicorn my_fastagency_app.deployment.main:app
        ```

=== "FastAPI + Mesop"

    In this setup, we need to run **two** commands in **separate** terminal windows:

    - Start **FastAPI** application using uvicorn, in the root of your project run:
    !!! note "Terminal 1"
        ```
        uvicorn my_fastagency_app.deployment.main_1_fastapi:app --host 0.0.0.0 --port 8008 --reload
        ```

    - Start **Mesop** web interface using gunicorn, in the root of your project run:
    !!! note "Terminal 2"
        ```
        gunicorn my_fastagency_app.deployment.main_2_mesop:app -b 0.0.0.0:8888 --reload
        ```

=== "NATS + FastAPI + Mesop"

    The **NATS** docker container is started automatically by Cookiecutter for this setup. In this setup, we need to run **three** commands in **separate** terminal windows:

    - Start **FastAPI** application that provides a conversational workflow, in the root of your project run::
    !!! note "Terminal 1"
        ```
        uvicorn my_fastagency_app.deployment.main_1_nats:app --reload
        ```

    - Start **FastAPI** application integrated with a **NATS** messaging system, in the root of your project run::
    !!! note "Terminal 2"
        ```
        uvicorn my_fastagency_app.deployment.main_2_fastapi:app --host 0.0.0.0 --port 8008 --reload
        ```

    - Start **Mesop** web interface using gunicorn, in the root of your project run::
    !!! note "Terminal 3"
        ```
        gunicorn my_fastagency_app.deployment.main_3_mesop:app -b 0.0.0.0:8888 --reload
        ```


### Output

The outputs will vary based on the interface, here is the output of the last terminal starting UI:

```console
[2024-10-10 13:19:18 +0530] [23635] [INFO] Starting gunicorn 23.0.0
[2024-10-10 13:19:18 +0530] [23635] [INFO] Listening at: http://127.0.0.1:8000 (23635)
[2024-10-10 13:19:18 +0530] [23635] [INFO] Using worker: sync
[2024-10-10 13:19:18 +0530] [23645] [INFO] Booting worker with pid: 23645
```

![Initial message](./images/chat-init.png)


## Deployment

### Building the Docker Image

If you created the project using Cookiecutter, then building the Docker image is as simple as running the provided script, as shown below:

```console
./scripts/build_docker.sh
```

Running the above command will build the Docker image. If the build is successful, you will see output similar to the following:

<details>
    <summary>Output</summary>
    ```console
    Building fastagency docker image
    #0 building with "default" instance using docker driver

    #1 [internal] load build definition from Dockerfile
    #1 transferring dockerfile: 1.41kB done
    #1 DONE 0.0s

    #2 [internal] load metadata for docker.io/library/python:3.12
    #2 DONE 1.6s

    #3 [internal] load .dockerignore
    #3 transferring context: 34B done
    #3 DONE 0.0s

    #4 [internal] load build context
    #4 transferring context: 14.06kB done
    #4 DONE 0.0s

    #5 [1/8] FROM docker.io/library/python:3.12@sha256:fccc38d7080ff9883ee85a65a340384d04eb1c148a7222439b3dc5d4f0f72025
    ...
    ...
    ...
    #12 DONE 0.2s

    #13 exporting to image
    #13 exporting layers
    #13 exporting layers 0.9s done
    #13 writing image sha256:d5b5432294fa293e3f8d5a2128c2ff012faa640fb552c43ce5faf240bce8bc0f done
    #13 naming to docker.io/library/deploy_fastagency done
    #13 DONE 0.9s
    Successfully built fastagency docker image
    ```
</details>

### Running the Docker Image

Similarly, running the Docker container is as simple as running the provided script, as shown below:

```console
./scripts/run_docker.sh
```

Running the above command will start the Docker container in the foreground with the following output:

<details>
    <summary>Output</summary>
    ```console
    Number of workers: 1
    Nginx config:
    upstream mesop_backend {
        # Enable sticky sessions with IP hash
        ip_hash;

        server 127.0.0.1:8889;

    }

    server {
        listen 8888;
        server_name localhost;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN";
        add_header X-Content-Type-Options "nosniff";
        add_header X-XSS-Protection "1; mode=block";

        location / {
            proxy_pass http://mesop_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_redirect off;
            proxy_buffering off;

            # WSGI support
            proxy_set_header X-Forwarded-Host $server_name;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
    }
    Starting gunicorn on port 8889
    2024/11/12 07:52:47 [warn] 10#10: the "user" directive makes sense only if the master process runs with super-user privileges, ignored in /etc/nginx/nginx.conf:1
    [2024-11-12 07:52:47 +0000] [12] [INFO] Starting gunicorn 23.0.0
    [2024-11-12 07:52:47 +0000] [12] [INFO] Listening at: http://0.0.0.0:8889 (12)
    [2024-11-12 07:52:47 +0000] [12] [INFO] Using worker: sync
    [2024-11-12 07:52:47 +0000] [29] [INFO] Booting worker with pid: 29
    flaml.automl is not available. Please install flaml[automl] to enable AutoML functionalities.
    2024-11-12 07:52:49,054 [INFO] Patching static file serving in Mesop
    2024-11-12 07:52:49,055 [INFO] Initializing MesopUI: <fastagency.ui.mesop.mesop.MesopUI object at 0x74b4128986b0>
    2024-11-12 07:52:49,059 [INFO] Initialized MesopUI: <fastagency.ui.mesop.mesop.MesopUI object at 0x74b4128986b0>
    2024-11-12 07:52:49,059 [INFO] Initializing MesopUI: <fastagency.ui.mesop.mesop.MesopUI object at 0x74b403fffb30>
    2024-11-12 07:52:49,059 [INFO] Initialized MesopUI: <fastagency.ui.mesop.mesop.MesopUI object at 0x74b403fffb30>
    2024-11-12 07:52:49,059 [INFO] Initializing FastAgency <FastAgency title=Write FastAgency Docs> with workflows: <fastagency.adapters.fastapi.base.FastAPIProvider object at 0x74b416f21010> and UI: <fastagency.ui.mesop.mesop.MesopUI object at 0x74b403fffb30>
    2024-11-12 07:52:49,059 [INFO] Initialized FastAgency: <FastAgency title=Write FastAgency Docs>
    2024-11-12 07:52:49,068 [INFO] Importing autogen.base.py
    INFO:     Started server process [11]
    INFO:     Waiting for application startup.
    INFO:     Application startup complete.
    INFO:     Uvicorn running on http://0.0.0.0:8008 (Press CTRL+C to quit)
    ```
</details>

### Deploying to Fly.io

If you created the project using Cookiecutter, there are built-in scripts to deploy your workflow to [**Fly.io**](https://fly.io/). In Fly.io, the application namespace is global, so the application name you chose might already be taken. To check your application's name availability and to reserve it, you can run the following script:

```console
./scripts/register_to_fly_io.sh
```

Running the above command will prompt you to log in to your Fly.io account (if not already logged in) by opening a fly.io URL in your browser. The login prompt will look like this:

```console
Checking if already logged into fly.io
Logging into fly.io
failed opening browser. Copy the url (https://fly.io/app/auth/cli/78366a6d347a377a6e346465776167726f6b693537666a333674346978626d37) into a browser and continue
Opening https://fly.io/app/auth/cli/78366a6d347a377a6e346465776167726f6b693537666a333674346978626d37 ...

Waiting for session...
```

After logging in, the script will check if the application name is available and reserve it if it is. The reserved app domain for Fly.io is saved in a file called "registered_app_domain.txt". The output of running the script will look like this:

<details>
    <summary>Output</summary>
    ```console
    successfully logged in
    Registering app name in fly.io
    New app created: test-registration
    App name registered successfully
    Registered app name is:
    test-registration.fly.dev
    ```
</details>

#### Deploying to Fly.io manually

Once you have reserved your application name, you can test whether you can deploy your application to Fly.io using the following script:

```console
./scripts/deploy_to_fly_io.sh
```

This script will deploy your application to Fly.io without any further input. The output will look like this:

<details>
    <summary>Output</summary>
    ```console
    Checking if already logged into fly.io
    Already logged into fly.io
    Deploying to fly.io
    ==> Verifying app config
    Validating fly.toml
    ✓ Configuration is valid
    --> Verified app config
    ==> Building image
    ==> Building image with Depot
    --> build:  (​)
    [+] Building 15.2s (13/13) FINISHED
    ...
    ...
    ...
    --> Build Summary:  (​)
    --> Building image done
    image: registry.fly.io/write-fastagency-docs-delicate-waterfall-7272:deployment-01JCFQP31QFJWA9HVVYPZYH1QN
    image size: 498 MB

    Watch your deployment at https://fly.io/apps/write-fastagency-docs-delicate-waterfall-7272/monitoring

    Provisioning ips for write-fastagency-docs-delicate-waterfall-7272
    Dedicated ipv6: 2a09:8280:1::4f:f553:0
    Shared ipv4: 66.241.124.140
    Add a dedicated ipv4 with: fly ips allocate-v4

    This deployment will:
    * create 2 "app" machines

    No machines in group app, launching a new machine
    Creating a second machine to increase service availability
    Finished launching new machines
    -------
    NOTE: The machines for [app] have services with 'auto_stop_machines = "stop"' that will be stopped when idling

    -------
    Checking DNS configuration for write-fastagency-docs-delicate-waterfall-7272.fly.dev

    Visit your newly deployed app at https://write-fastagency-docs-delicate-waterfall-7272.fly.dev/
    Setting secrets
    Updating existing machines in 'write-fastagency-docs-delicate-waterfall-7272' with rolling strategy

    -------
    ✔ [1/2] Machine 48e2764ce93e58 [app] update succeeded
    ✔ [2/2] Machine e825942c739518 [app] update succeeded
    -------
    Checking DNS configuration for write-fastagency-docs-delicate-waterfall-7272.fly.dev
    ```
</details>

The preferred way to deploy the FastAgency application to Fly.io is by using [**GitHub Actions**](https://github.com/features/actions){target="_blank"} which is explained in the next section.

#### Deploying to Fly.io using GitHub Actions

The preferred way to deploy your application to Fly.io is by using [**GitHub Actions**](https://github.com/features/actions){target="_blank"}. You can deploy using Github Actions by following these steps:

1. Create a [**new GitHub repository**](https://github.com/new){target="_blank"} with your FastAgency project name.

2. Add the following secrets to your GitHub repository:

    - `FLY_API_TOKEN`: Your Fly.io API token.
    - `OPENAI_API_KEY`: Your OpenAI API key.

    To learn how to create keys and add them as secrets, use the following links:

    - [**Creating a Fly.io API token**](https://fly.io/docs/security/tokens/#manage-tokens-in-the-dashboard){target="_blank"}
    - [**Creating an OpenAI API key**](https://platform.openai.com/api-keys){target="_blank"}
    - [**Adding secrets to your GitHub repository**](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-a-repository){target="_blank"}

3. In your devcontainer's terminal, run the following commands to commit and push your project to the new GitHub repository:

    ```console
    git init
    git add .
    git commit -m "Initial commit"
    git remote add origin https://github.com/<username>/<repo-name>.git
    git branch -M main
    git push -u origin main
    ```

    Make sure to replace `<username>` and `<repo-name>` with your GitHub username and repository name, respectively.

Once these steps are complete, the GitHub Actions workflow will automatically deploy your application to Fly.io. And continue to do so every time you push changes to your repository's **main** branch.

!!! danger
    If you skip these steps, the GitHub Actions workflow will fail when changes are pushed to the repository's **main** branch.
